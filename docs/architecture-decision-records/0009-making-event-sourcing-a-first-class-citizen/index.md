# ADR0009: Making event sourcing a first class citizen

Status: Accepted and active.

## Context

Without EF's change tracker, keeping an aggregate up-to-date with a relational
store involves significant work: manually scanning an aggregate for changes and
generating SQL, like EF does, is repetitive and infeasible to code by hand.

By instead combining events generated by Core with an immediately updated
read-model, change tracking becomes feasible across complex aggregates.

The immediately updated read-model is a relational model, but could've been JSON
documents to make future database migrations easier.

As an alternative to event sourcing, with databases gaining JSON query support,
we could've created one table for each aggregate. Serialization and
deserialization of an object tree then would become trivial. Similar for change
tracking, which would be comparing two JSON documents.

Serializing/deserializing F# domain types poses a few problems, though. When
most every field on domain types is a value object, the JSON becomes
bloated. Writing manual serialization/deserialization code becomes tedious, and
possibly using UMX for value objects would solve this issue.

## Decision

The sample is explicitly event sourced with events expressed in past tense,
stored in the `Events` table.

## Consequences

Guarantying the replay of events, we're forced to ensure events are accurate for
auditing.
